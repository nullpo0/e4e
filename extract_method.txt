def extract_noise_laplacian(data_loader, num_layers=17, ksize=3, device='cuda'):
    """
    Laplacian í•„í„° ê¸°ë°˜ ê³ ì£¼íŒŒ ì¶”ì¶œ í•¨ìˆ˜.
    DoG ê¸°ë°˜ extract_noise() êµ¬ì¡°ë¥¼ ê·¸ëŒ€ë¡œ ë”°ë¦„.
    
    Args:
        data_loader: ì´ë¯¸ì§€ ë°°ì¹˜ ë¡œë” (B,C,H,W)
        num_layers: ë…¸ì´ì¦ˆ ë§µì„ ì¶”ì¶œí•  ë ˆì´ì–´ ìˆ˜
        ksize: Laplacian ì»¤ë„ í¬ê¸° (3, 5 ë“±)
        device: torch ë””ë°”ì´ìŠ¤
    Returns:
        all_noises_per_layer: ê° í•´ìƒë„ë³„ Laplacian ê³ ì£¼íŒŒ ë§µ ë¦¬ìŠ¤íŠ¸
    """

    all_noises_per_layer = [[] for _ in range(num_layers)]

    for batch in data_loader:
        img = batch.to(device).float()
        img_gray = img.mean(dim=1, keepdim=True)
        B, _, H, W = img_gray.shape
        img_np = img_gray.detach().cpu().numpy()

        lap_batch = []
        for b in range(B):
            img_b = img_np[b, 0]
            # Laplacian í•„í„° ì ìš©
            lap = cv2.Laplacian(img_b, cv2.CV_32F, ksize=ksize)
            lap_batch.append(lap[None, None])

        noise_tensor = torch.tensor(np.concatenate(lap_batch), dtype=torch.float32, device=device)

        # ê° layer í•´ìƒë„ì— ë§ê²Œ interpolate + normalize
        for layer_idx in range(num_layers):
            res = (layer_idx + 5) // 2
            h = w = 2 ** res
            n = F.interpolate(noise_tensor, size=(h, w), mode='bilinear', align_corners=False)
            n = (n - n.mean(dim=[1,2,3], keepdim=True)) / (n.std(dim=[1,2,3], keepdim=True) + 1e-8)
            all_noises_per_layer[layer_idx].append(n)

    for i in range(num_layers):
        all_noises_per_layer[i] = torch.cat(all_noises_per_layer[i], dim=0)

    return all_noises_per_layer

def extract_noise_highpass(data_loader, num_layers=17, sigma=2.0, device='cuda'):
    """
    Gaussian ê¸°ë°˜ High-pass í•„í„°ë¡œ ê³ ì£¼íŒŒ(ë…¸ì´ì¦ˆ) ì¶”ì¶œ.

    Args:
        data_loader: torch DataLoader (B,C,H,W)
        num_layers: ë…¸ì´ì¦ˆ ë§µ ì¶”ì¶œ ë ˆì´ì–´ ìˆ˜
        sigma: Gaussian blur í‘œì¤€í¸ì°¨ (ì»¤ì§ˆìˆ˜ë¡ ì €ì£¼íŒŒê°€ ë” ë„“ê²Œ ì œê±°)
        device: torch device ('cuda' or 'cpu')
    Returns:
        all_noises_per_layer: ê° ë ˆì´ì–´ë³„ ê³ ì£¼íŒŒ ë…¸ì´ì¦ˆ ë§µ ë¦¬ìŠ¤íŠ¸
    """

    all_noises_per_layer = [[] for _ in range(num_layers)]

    for batch in data_loader:
        img = batch.to(device).float()
        img_gray = img.mean(dim=1, keepdim=True)  # grayscale ë³€í™˜
        B, _, H, W = img_gray.shape
        img_np = img_gray.detach().cpu().numpy()

        high_batch = []
        for b in range(B):
            img_b = img_np[b, 0]

            # Gaussian Blur (ì €ì£¼íŒŒ)
            low_pass = cv2.GaussianBlur(img_b, (0, 0), sigma)

            # ì›ë³¸ - ì €ì£¼íŒŒ = ê³ ì£¼íŒŒ
            high_pass = img_b - low_pass

            high_batch.append(high_pass[None, None])

        noise_tensor = torch.tensor(np.concatenate(high_batch), dtype=torch.float32, device=device)

        # í•´ìƒë„ë³„ë¡œ interpolation + normalization
        for layer_idx in range(num_layers):
            res = (layer_idx + 5) // 2
            h = w = 2 ** res
            n = F.interpolate(noise_tensor, size=(h, w), mode='bilinear', align_corners=False)
            n = (n - n.mean(dim=[1,2,3], keepdim=True)) / (n.std(dim=[1,2,3], keepdim=True) + 1e-8)
            all_noises_per_layer[layer_idx].append(n)

    for i in range(num_layers):
        all_noises_per_layer[i] = torch.cat(all_noises_per_layer[i], dim=0)

    return all_noises_per_layer

from scipy.fftpack import dct, idct

def extract_noise_dct_multiscale(data_loader, num_layers=17, keep_ratio=0.1, device='cuda'):
    """
    DCT ê¸°ë°˜ ë©€í‹°ìŠ¤ì¼€ì¼ ê³ ì£¼íŒŒ(ë…¸ì´ì¦ˆ) ì¶”ì¶œ í•¨ìˆ˜.
    í•´ìƒë„ë³„ë¡œ ë‹¤ìš´ìƒ˜í”Œ í›„, ê° ìŠ¤ì¼€ì¼ì—ì„œ DCT ê¸°ë°˜ ê³ ì£¼íŒŒ ì¶”ì¶œì„ ìˆ˜í–‰í•¨.

    Args:
        data_loader: torch DataLoader (B,C,H,W)
        num_layers: ë…¸ì´ì¦ˆ ë§µ ë ˆì´ì–´ ìˆ˜
        keep_ratio: ì €ì£¼íŒŒ ìœ ì§€ ë¹„ìœ¨ (0.1 â†’ í•˜ìœ„ 10%ëŠ” ì œê±°í•˜ì§€ ì•ŠìŒ)
        device: torch device
    Returns:
        all_noises_per_layer: ê° ë ˆì´ì–´ë³„ ê³ ì£¼íŒŒ ë§µ ë¦¬ìŠ¤íŠ¸
    """
    all_noises_per_layer = [[] for _ in range(num_layers)]

    for batch in data_loader:
        img = batch.to(device).float()
        img_gray = img.mean(dim=1, keepdim=True)  # (B,1,H,W)
        B, _, H, W = img_gray.shape
        img_np = img_gray.detach().cpu().numpy()

        # ğŸ”¹ ê° ë ˆì´ì–´ë³„ í•´ìƒë„ì—ì„œ ë…¸ì´ì¦ˆ ì¶”ì¶œ
        for layer_idx in range(num_layers):
            res = (layer_idx + 5) // 2
            h = w = 2 ** res

            dct_batch = []
            for b in range(B):
                # í•´ìƒë„ë³„ ë‹¤ìš´ìƒ˜í”Œë§
                img_resized = cv2.resize(img_np[b, 0], (w, h), interpolation=cv2.INTER_AREA)

                # DCT ë³€í™˜
                dct_freq = dct(dct(img_resized.T, norm='ortho').T, norm='ortho')

                # ì €ì£¼íŒŒ ë§ˆìŠ¤í¬ ìƒì„±
                mask = np.ones_like(dct_freq)
                h_keep = int(h * keep_ratio)
                w_keep = int(w * keep_ratio)
                mask[:h_keep, :w_keep] = 0  # ì €ì£¼íŒŒ ì œê±°

                # ê³ ì£¼íŒŒ ì„±ë¶„ë§Œ ë‚¨ê¸°ê¸°
                high_freq_dct = dct_freq * mask

                # ì—­DCTë¡œ ë³µì›
                high_freq_img = idct(idct(high_freq_dct.T, norm='ortho').T, norm='ortho')

                dct_batch.append(high_freq_img[None, None])

            # í…ì„œ ë³€í™˜ ë° ì •ê·œí™”
            noise_tensor = torch.tensor(np.concatenate(dct_batch), dtype=torch.float32, device=device)
            noise_tensor = (noise_tensor - noise_tensor.mean(dim=[1,2,3], keepdim=True)) / (
                noise_tensor.std(dim=[1,2,3], keepdim=True) + 1e-8
            )

            all_noises_per_layer[layer_idx].append(noise_tensor)

    # ë ˆì´ì–´ë³„ë¡œ concat
    for i in range(num_layers):
        all_noises_per_layer[i] = torch.cat(all_noises_per_layer[i], dim=0)

    return all_noises_per_layer


def extract_noise_dct(data_loader, num_layers=17, keep_ratio=0.1, device='cuda'):
    """
    DCT ê¸°ë°˜ ê³ ì£¼íŒŒ(ë…¸ì´ì¦ˆ) ì¶”ì¶œ í•¨ìˆ˜.
    
    Args:
        data_loader: torch DataLoader (B,C,H,W)
        num_layers: ë…¸ì´ì¦ˆ ë§µ ë ˆì´ì–´ ìˆ˜
        keep_ratio: ì €ì£¼íŒŒ ìœ ì§€ ë¹„ìœ¨ (0.1 â†’ í•˜ìœ„ 10%ë§Œ ë‚¨ê¸°ê³  ë‚˜ë¨¸ì§€ ê³ ì£¼íŒŒ)
        device: torch device
    Returns:
        all_noises_per_layer: ê° ë ˆì´ì–´ë³„ ê³ ì£¼íŒŒ ë§µ ë¦¬ìŠ¤íŠ¸
    """
    all_noises_per_layer = [[] for _ in range(num_layers)]

    for batch in data_loader:
        img = batch.to(device).float()
        img_gray = img.mean(dim=1, keepdim=True)
        B, _, H, W = img_gray.shape
        img_np = img_gray.detach().cpu().numpy()

        dct_batch = []
        for b in range(B):
            img_b = img_np[b, 0]

            # DCT ë³€í™˜ (2D)
            dct_freq = dct(dct(img_b.T, norm='ortho').T, norm='ortho')

            # ì €ì£¼íŒŒ ë§ˆìŠ¤í¬ ìƒì„±
            mask = np.ones_like(dct_freq)
            h_keep = int(H * keep_ratio)
            w_keep = int(W * keep_ratio)
            mask[:h_keep, :w_keep] = 0  # ì¤‘ì•™(ì €ì£¼íŒŒ) ì œê±° X â†’ 0ìœ¼ë¡œ ë§Œë“¤ì–´ì„œ ì œê±°

            # ê³ ì£¼íŒŒë§Œ ë‚¨ê¸°ê¸°
            high_freq_dct = dct_freq * mask

            # ì—­DCTë¡œ ë³µì›
            high_freq_img = idct(idct(high_freq_dct.T, norm='ortho').T, norm='ortho')

            dct_batch.append(high_freq_img[None, None])

        noise_tensor = torch.tensor(np.concatenate(dct_batch), dtype=torch.float32, device=device)

        # í•´ìƒë„ë³„ interpolation + normalization
        for layer_idx in range(num_layers):
            res = (layer_idx + 5) // 2
            h = w = 2 ** res
            n = F.interpolate(noise_tensor, size=(h, w), mode='bilinear', align_corners=False)
            n = (n - n.mean(dim=[1,2,3], keepdim=True)) / (n.std(dim=[1,2,3], keepdim=True) + 1e-8)
            all_noises_per_layer[layer_idx].append(n)

    for i in range(num_layers):
        all_noises_per_layer[i] = torch.cat(all_noises_per_layer[i], dim=0)

    return all_noises_per_layer